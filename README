terst - A terse, easy-to-use testing library for Go (golang)

DESCRIPTION

    * Provides the following testing methods:
        Equal, Unequal, Pass, Fail, Is, IsNot, Like, Unlike, Compare
    * Compatible with (and works via) the standard testing package

SYNOPSIS

    import (
        "testing"
        . "terst"
    )

    func Test(t *testing.T) {
        Terst(t) // Associate terst methods with t (the current testing.T)

        Is(getApple(), "apple") // Pass
        Is(getOrange(), "orange") // Fail: emits nice-looking diagnostic 

        Compare(1, ">", 0) // Pass
        Compare(1, "==", 1.0) // Pass
    }

    func getApple() string {
        return "apple"
    }

    func getOrange() string {
        return "apple" // Intentional mistake
    }

USAGE

    Terst( *testing.T )

        At the top of your func Test*() method, tell terst to use the
        passed *testing.T by invoking this method.  You must do this
        for each Test*()

        terst will use the given *testing.T to log output and register
        failures

    Equal( have interface{}, want interface{} )
        Test have against want via ==
        No special coercion or type inspection is done
        If the type is incomparable this will panic

    Unequal( ... )
        Test have against want via !=
        Like Equal, no special coercion or type inspection is done

    Pass( result bool )
        Passing if result is true 

    Fail( result bool )
        Passing if result is false 

    Is( have interface{}, want string )
        Convert have to a string (via fmt.Sprintf("%v")) and test
        against want via ==

    Is( have interface{}, want interface{} )
        A shortcut for: Compare(have, "==", want)
        If have/want is a slice ([]type), struct, or similar, Is will perform
        a reflect.DeepEqual() comparison

    IsNot( ... )
        Same behavior as with Is but with the opposite result

    Like( have interface{}, want string )
        A regular expression test. Convert have to a string
        (via fmt.Sprintf("%v")) and test against the regular
        expression specified by want
        Passing is a match: The result of regexp.Match( ... ) is true

    Like( have interface{}, want interface{} )
        A shortcut for: Compare( have, "{}~ ==", want )
        If have/want is a slice ([]type), struct, or similar, Like
        will perform a reflect.DeepEqual() comparison

    Unike( have interface{}, want string )
        Same behavior as with Like but with the opposite result
        Passing is a mismatch: The result of regexp.Match( ... ) is false

    Unlike( have interface{}, want interface{} )
        A shortcut for: Compare( have, "{}~ !=", want )

    Compare( have interface{}, operator string, want interface{} )
        Compare have to want using the specified operator
        The operator can be one of the following:
            ==
            !=
            <
            <=
            >
            >=

        Compare (in the default mode) is not strict when comparing numeric
        types, and will make a best effort to promote have and want to the
        same type

        Compare will promote int* and uint* to math/big.Int for testing
        against eachother

        Compare will promote int*, uint*, and float32 to float64 for
        float testing

        For example, Compare(float32(1.0), "<", int8(2)) is a valid test
        The expression equivalent (result := float32(1.0) < int8(2)) will not
        parse/compile because of a type mismatch

    ---

    Each of the methods above can take one additional (optional) argument,
    which is a string describing the test. If the test fails, this
    description will be included with the test output For example:

        Is(2 + 2, float32(5), "This result is Doubleplusgood")

        --- FAIL: Test (0.00 seconds)
             test.go:17: This result is Doubleplusgood
                Failed test (Is)
                       got: 4 (int)
                  expected: 5 (float32)

AUTHOR
    Robert Krimen <robertkrimen@gmail.com>

FUTURE
- Add Catch() for testing panic()
- Add Same() for testing via .DeepEqual && == (without panicking?)
- Add StrictCompare to use {}= scoping
- Add BigCompare for easier math/big.Int testing?
- Support the complex type in Compare()
- Equality test for NaN?
- Better syntax for At*
- Need IsType/TypeIs
